#!/usr/bin/env node
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration
const LOG_DIR = path.join(__dirname, '../../build/logs');
const DEBUG_LOG = path.join(LOG_DIR, 'tag_debug.log');
const HISTORY_LOG = path.join(LOG_DIR, 'tag_history.log');
const ERROR_LOG = path.join(LOG_DIR, 'tag_error.log');
const ENV_FILE = path.join(__dirname, '../../build/.env');

// Initialize logs
function initLogs() {
  if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR, { recursive: true });
  }
  fs.writeFileSync(DEBUG_LOG, '');
  if (!fs.existsSync(HISTORY_LOG)) fs.writeFileSync(HISTORY_LOG, '');
  if (!fs.existsSync(ERROR_LOG)) fs.writeFileSync(ERROR_LOG, '');
}

function debugLog(message) {
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
  fs.appendFileSync(DEBUG_LOG, `[DEBUG ${timestamp}] ${message}\n`);
}

function historyLog(message) {
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
  fs.appendFileSync(HISTORY_LOG, `${timestamp} - ${message}\n`);
}

function errorLog(message) {
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
  fs.appendFileSync(ERROR_LOG, `[ERROR ${timestamp}] ${message}\n`);
}

function getTagVersion() {
  try {
    debugLog('Reading TAG_VERSION from .env');
    const envContent = fs.readFileSync(ENV_FILE, 'utf8');
    const match = envContent.match(/TAG_VERSION=([^\n]+)/);
    if (!match) throw new Error('TAG_VERSION not found in .env');
    debugLog(`Found TAG_VERSION: ${match[1]}`);
    return match[1];
  } catch (error) {
    errorLog(`getTagVersion error: ${error.message}`);
    throw error;
  }
}

function tagExists(tagName) {
  try {
    execSync(`git rev-parse ${tagName}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

function createAndPushTag() {
  const baseTagVersion = getTagVersion();
  const tagName = `v${baseTagVersion}`;
  
  debugLog(`Attempting to create tag: ${tagName}`);

  if (tagExists(tagName)) {
    const errorMsg = `Tag ${tagName} already exists - aborting`;
    errorLog(errorMsg);
    throw new Error(errorMsg);
  }

  try {
    debugLog(`Creating tag: ${tagName}`);
    execSync(`git tag -a ${tagName} -m "${tagName}"`, { stdio: 'inherit' });
    
    debugLog(`Pushing tag: ${tagName}`);
    execSync(`git push origin ${tagName}`, { stdio: 'inherit' });
    
    historyLog(`Created and pushed tag: ${tagName}`);
    console.log(`✅ Successfully deployed tag: ${tagName}`);
  } catch (error) {
    errorLog(`Tag creation failed: ${error.message}`);
    throw error;
  }
}

// Main execution
initLogs();
debugLog('Starting post-commit hook');

try {
  // Get the CURRENT commit message (not last)
  const commitMsg = execSync('git log -1 --pretty=%B', { encoding: 'utf8' }).trim();
  debugLog(`Current commit message: "${commitMsg}"`);

  if (commitMsg.includes('-d')) {
    debugLog('Deployment flag (-d) found');
    
    // Verify we're on the expected branch (e.g., main/master)
    const branch = execSync('git symbolic-ref --short HEAD', { encoding: 'utf8' }).trim();
    if (!['main', 'master'].includes(branch)) {
      throw new Error(`Deployment tags only allowed on main/master (current: ${branch})`);
    }

    // Create and push tag
    createAndPushTag();
    
    // Push the commit if not already pushed
    try {
      execSync('git push origin HEAD', { stdio: 'inherit' });
    } catch (pushError) {
      debugLog('Commit was already pushed or push failed');
    }
  }
} catch (error) {
  errorLog(`Error: ${error.message}`);
  console.error(`❌ ${error.message}`);
} finally {
  debugLog('Post-commit hook completed');
}